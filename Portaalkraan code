/*
 */

#include <avr/io.h>
#include <avr/delay.h>
#include <stdio.h>
#include <stdlib.h>
#include <avr/interrupt.h>

// Afstandssensor
#define TRIGGER_x         PB7     // digital 9
#define ECHO_x            PD0     // digital 21
#define TRIGGER_z         PB5
#define ECHO_z            PB4
#define TRIG_HOOG_x       PORTH |= (1 << TRIGGER_x)
#define TRIG_LAAG_x       PORTH &= ~(1 << TRIGGER_x)
#define ECHO_HOOG_x       PIND &(1 << ECHO_x)
#define TRIG_HOOG_z       PORTB |= (1 << TRIGGER_z)
#define TRIG_LAAG_z       PORTB &= ~(1 <<TRIGGER_z)
#define ECHO_HOOG_z       PINB &(1 << ECHO_z)

// Motor pins
#define MOTOR_X      PH6
#define MOTOR_X2     PH3
#define MOTOR_Y      PE3
#define MOTOR_Y2     PG5
#define MOTOR_Z      PH5
#define MOTOR_Z2     PH4

// Eindstopjes
#define EIND_X     PF1         // rechts, voor
#define EIND_2X     PF2         // rechts, achter
#define EIND_Z      PF3         // links
#define EIND_2Z     PF4         // rechts

// Knoppen
#define KNOP        PF7
#define KNOP2       PK0

// Noodstop
#define NOODSTOP    PK1

// Elektromagneet
#define ELEKTROMAGNEET  PE4

void initTimer0 (void)
{
    // Timer 0 is de systeemtimer (overflow)
    TCCR0A = 0;
    // 16000000 Hz / 64 / 256 = 976.56 Hz
    // start timer 0, prescaler = 64
    // 1 tick = 64 / 16000000 sec
    TCCR0B = TCCR0B | (1 << CS01) | (1 << CS00);
    // enable timer 0 voor overflow interrupt flag
    TIMSK0 = TIMSK0 | (1 << TOIE0);
}

void init_sensor()
{
    DDRH |= (1 << TRIGGER_x);
    DDRD &= ~(1 << ECHO_x);
    DDRB |= (1 << TRIGGER_z);
    DDRB &= ~(1 << ECHO_z);

    EIMSK |= (1 << INT0);
    EICRA |= (1 << ISC00);
    sei();

    // timer 1, 16 bits (2^16), mode 0
    TCCR1A = 0;

    // 16000000 Hz / 1 / 65536 = 244.141 Hz     , 1 tick = 1 / 16000000 sec
    // 16000000 Hz / 8 / 65536 = 30.518 Hz      , 1 tick = 8 / 16000000 sec
    // 16000000 Hz / 64 / 65536 = 3.815 Hz      , 1 tick = 64 / 16000000 sec
    // 16000000 Hz / 256 / 65536 = 0.954 Hz     , 1 tick = 256 / 16000000 sec
    // 16000000 Hz / 1024 / 65536 = 0.238 Hz    , 1 tick = 1024 / 16000000 sec

    // start timer 1, prescaler = 1
    TCCR1B |= (0 << CS12) | (0 << CS11) | (1 << CS10);

}

volatile int teller=0;
// Interrupt voor noodstop
ISR(TIMER0_OVF_vect)
{
    int noodstop = !(PINK &(1 << NOODSTOP));
    if(teller == 488)
    {
        if(noodstop)
        {
            // elektromagneet aan
            PORTE |= (1 << ELEKTROMAGNEET);
            // alle motoren uit
            PORTH &= ~(1 << PH6);
            PORTF &= ~(1 << PH3);
            PORTH &= ~(1 << PH5);
            PORTF &= ~(1 << PH4);
            PORTH &= ~(1 << PE3);
            PORTF &= ~(1 << PG5);
        }
        teller = 0;
    }
    else
    {
        teller++;
    }
}

uint16_t ticks_x = 0;
volatile int echo_last = 0;
volatile int echo = 0;
volatile int send = 0;
volatile int flag = 0;
volatile int echo_current = 0;

ISR(INT0_vect)
{
    echo_current = ECHO_HOOG_x;
    if( echo_current != echo_last )               // signaal verstuurd
    {
        if( echo_current && !echo)
        {
            // begin met tellen
            TCNT1 = 0;
            echo = 1;
        }
        else if(!echo_current && echo)          // signaal ontvangen
        {
            //stop met tellen (aflezen)
            ticks_x = TCNT1;
            flag = 1;
        }
        echo_last = echo_current;
    }
}

void check_echosensor_x()
{
    if(send)
    {
        return;
    }
    else
    {
        TRIG_LAAG_x;
        _delay_us(2);
        TRIG_HOOG_x;
        _delay_us(10);
        TRIG_LAAG_x;
        _delay_us(1000);

        send = 1;
    }
}

void check_echosensor_z()
{
    if(send)
    {
        return;
    }
    else
    {
        TRIG_LAAG_z;
        _delay_us(2);
        TRIG_HOOG_z;
        _delay_us(10);
        TRIG_LAAG_z;
        _delay_us(1000);


        send = 1;
    }
}


int main(void)
{
    initTimer0();
    init_sensor();
    sei();

    // Initialisatie
    //Eindstopjes
    DDRF &= ~(1 << EIND_Z);
    DDRF &= ~(1 << EIND_2Z);
    DDRF &= ~(1 << EIND_X);
    DDRF &= ~(1 << EIND_2X);

    // Knoppen
    DDRF &= ~(1 << KNOP);
    DDRF &= ~(1 << KNOP2);

    // Noodstop
    DDRF &= ~(1 << NOODSTOP);

    // Motoren
    // X-as (langzame motor)
    DDRH |= (1 << PH6);
    DDRH |= (1 << PH3);
    PORTH &= ~(1 << PH6);       // rechtsom vanaf voorkant
    PORTH &= ~(1 << PH3);       // linksom vanaf voorkant
    // Y-as (snelle motor)
    DDRH |= (1 << PH5);
    DDRH |= (1 << PH4);
    PORTH &= ~(1 << PH5);       // Omlaag
    PORTH &= ~(1 << PH4);       // Omhoog
    // Z-as (langzame motor)
    DDRE |= (1 << PE3);
    DDRG |= (1 << PG5);
    PORTE &= ~(1 << PE3);       // linksom vanaf voorkant
    PORTG &= ~(1 << PG5);       // rechtsom vanaf voorkant

    // Elektromagneet
    DDRE |= (1 << ELEKTROMAGNEET);
    PORTE &= ~(1 << ELEKTROMAGNEET);


    // Eindstoppen
    int stop_z = !(PINF &(1 << EIND_Z));
    int stop_2z = !(PINF &(1 << EIND_2Z));
    int stop_x = !(PINF &(1 << EIND_X));
    int stop_2x = !(PINF &(1 << EIND_2X));

    int ticks_x = 0;
    int ticks_z_y_magneet = 0;
    float duration_x = 0;                   //travel time
    float duration_z_y_magneet = 0;         //travel time
    float distance_x = 0;
    float distance_z_y_magneet = 0;

    while(1)
    {
        /// Container oppakken
        //Motor x-as aan
        PORTH |= (1 << PH6);        // rechtsom, dus naar voren (vanaf de voorkant gezien)

        // Als het wiel de endswitch indrukt dan draait de motor de andere kant op
        if(stop_2x)
        {
            PORTH &= ~(1 << PH6);
            PORTH |= (1 << PH3);
        }
        else if(stop_x)
        {
            PORTH &= ~(1 << PH3);
            PORTH |= (1 << PH6);
        }

        check_echosensor_x();
        if(flag == 1)
        {
            // convert ticks to seconds
            duration_x = ticks_x / 16 ;
            // convert seconds to cm sound speed = 340 m/s
            distance_x = duration_x / 58.0 ;

            if(distance_x >= 5 && distance_x <= 10)
            {
                // Motor X-as uit
                PORTH &= ~(1 << PH6);
                PORTH &= ~(1 << PH3);
            }
        }


        // Motor z-as aan
        PORTG |= (1 << PG5);        // rechtsom, dus naar rechts (vanaf de voorkant gezien)

        // Als het wiel de endswitch indrukt dan draait de motor de andere kant op
        if(stop_2z)
        {
            PORTG &= ~(1 << PG5);
            PORTE |= (1 << PE3);
        }
        else if(stop_z)
        {
            PORTE &= ~(1 << PE3);
            PORTG |= (1 << PG5);
        }

        check_echosensor_z();
        if(flag == 1)
        {
            // convert ticks to seconds
            duration_z_y_magneet = ticks_z_y_magneet / 16 ;
            // convert seconds to cm sound speed = 340 m/s
            distance_z_y_magneet = duration_z_y_magneet / 58.0 ;

            if(distance_z_y_magneet >= 5 && distance_z_y_magneet <= 10)
            {
                // Motor z-as uit
                PORTE &= ~(1 << PE3);
                PORTG &= ~(1 << PG5);
                // Motor y-as aan, omlaag
                PORTH |= (1 << PH5);
                // Delay ... ms, motor y-as uit
                _delay_ms(2500);
                PORTH &= ~(1 << PH5);
                // Elektromagneet aan
                PORTE |= (1 << ELEKTROMAGNEET);
                // Motor y-as aan, omhoog
                PORTH |= (1 << PH4);
                // Delay ... ms, motor y-as uit
                _delay_ms(2500);
                PORTH &= ~(1 << PH4);
            }
        }



        /// Container ergens neerzetten
        //Motor x-as aan
        PORTH |= (1 << PH3);            // linksom, dus naar achteren (vanaf de voorkant gezien)

        // Als het wiel de endswitch indrukt dan draait de motor de andere kant op
        if(stop_2x)
        {
            PORTH &= ~(1 << PH6);
            PORTH |= (1 << PH3);
        }
        else if(stop_x)
        {
            PORTH &= ~(1 << PH3);
            PORTH |= (1 << PH6);
        }

        check_echosensor_x();
        if(flag == 1)
        {
            // convert ticks to seconds
            duration_x = ticks_x / 16 ;
            // convert seconds to cm
            distance_x = duration_x / 58.0 ;

            if(distance_x >= 5 && distance_x <= 10)
            {
                // Motor X-as uit
                PORTH &= ~(1 << PH3);
            }
        }

        // Motor z-as aan
        PORTE |= (1 << PE3);        // linksom, dus naar links (vanaf de voorkant gezien)

        // Als het wiel de endswitch indrukt dan draait de motor de andere kant op
        if(stop_2z)
        {
            PORTE |= (1 << PE3);
            PORTG &= ~(1 << PG5);
        }
        else if(stop_z)
        {
            PORTG |= (1 << PG5);
            PORTE &= ~(1 << PE3);
        }
        check_echosensor_z();
        if(flag == 1)
        {
            // convert ticks to seconds
            duration_x = ticks_x / 16 ;
            // convert seconds to cm
            distance_x = duration_x / 58.0 ;

            if(distance_z_y_magneet >= 5 && distance_z_y_magneet <= 10)
            {
                // Motor z-as uit
                PORTE &= ~(1 << PE3);
                PORTG &= ~(1 << PG5);
                // Motor y-as aan, omlaag
                PORTH |= (1 << PH5);
                // Delay ... ms, motor y-as uit
                _delay_ms(2500);
                PORTH &= ~(1 << PH5);
                // Elektromagneet aan
                PORTE |= (1 << ELEKTROMAGNEET);
                // Motor y-as aan, omhoog
                PORTH |= (1 << PH4);
                // Delay ... ms, motor y-as uit
                _delay_ms(2500);
                PORTH &= ~(1 << PH4);
            }
        }
    }

    return 0;
}



/// Medemogelijk gemaakt door: Cas Brugman (basis code van afstandssensor (HC-SR04) gemaakt)
